-- Enhanced Security Migration for YCCC Nursing Inventory\n-- This migration implements comprehensive security measures\n\n-- Enable Row Level Security on all tables\nALTER TABLE inventory_items ENABLE ROW LEVEL SECURITY;\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\n\n-- Create email whitelist table\nCREATE TABLE IF NOT EXISTS email_whitelist (\n  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n  email TEXT UNIQUE NOT NULL,\n  domain TEXT NOT NULL,\n  added_by UUID REFERENCES auth.users(id),\n  added_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  is_active BOOLEAN DEFAULT TRUE,\n  notes TEXT\n);\n\n-- Enable RLS on whitelist table\nALTER TABLE email_whitelist ENABLE ROW LEVEL SECURITY;\n\n-- Insert initial whitelisted emails\nINSERT INTO email_whitelist (email, domain, notes) VALUES \n('john.barr@mainecc.edu', 'mainecc.edu', 'Initial system administrator'),\n('*@mainecc.edu', 'mainecc.edu', 'All YCCC staff emails')\nON CONFLICT (email) DO NOTHING;\n\n-- Create audit log table for security monitoring\nCREATE TABLE IF NOT EXISTS audit_log (\n  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,\n  user_id UUID REFERENCES auth.users(id),\n  action TEXT NOT NULL,\n  table_name TEXT,\n  record_id TEXT,\n  old_values JSONB,\n  new_values JSONB,\n  ip_address INET,\n  user_agent TEXT,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Enable RLS on audit log\nALTER TABLE audit_log ENABLE ROW LEVEL SECURITY;\n\n-- Create function to check if email is whitelisted\nCREATE OR REPLACE FUNCTION is_email_whitelisted(email_address TEXT)\nRETURNS BOOLEAN AS $$\nBEGIN\n  -- Check for exact email match\n  IF EXISTS (\n    SELECT 1 FROM email_whitelist \n    WHERE email = LOWER(email_address) \n    AND is_active = TRUE\n  ) THEN\n    RETURN TRUE;\n  END IF;\n  \n  -- Check for domain wildcard match\n  IF EXISTS (\n    SELECT 1 FROM email_whitelist \n    WHERE email = '*@' || SPLIT_PART(LOWER(email_address), '@', 2)\n    AND is_active = TRUE\n  ) THEN\n    RETURN TRUE;\n  END IF;\n  \n  RETURN FALSE;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Create function to log audit events\nCREATE OR REPLACE FUNCTION log_audit_event(\n  p_action TEXT,\n  p_table_name TEXT DEFAULT NULL,\n  p_record_id TEXT DEFAULT NULL,\n  p_old_values JSONB DEFAULT NULL,\n  p_new_values JSONB DEFAULT NULL\n)\nRETURNS VOID AS $$\nBEGIN\n  INSERT INTO audit_log (\n    user_id,\n    action,\n    table_name,\n    record_id,\n    old_values,\n    new_values,\n    ip_address\n  ) VALUES (\n    auth.uid(),\n    p_action,\n    p_table_name,\n    p_record_id,\n    p_old_values,\n    p_new_values,\n    COALESCE(current_setting('request.headers', true)::json->>'x-forwarded-for', '0.0.0.0')::inet\n  );\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- RLS Policies for inventory_items table\nDROP POLICY IF EXISTS \"Users can view all inventory items\" ON inventory_items;\nDROP POLICY IF EXISTS \"Authenticated users can insert inventory items\" ON inventory_items;\nDROP POLICY IF EXISTS \"Users can update inventory items\" ON inventory_items;\nDROP POLICY IF EXISTS \"Users can delete inventory items\" ON inventory_items;\n\n-- Only allow whitelisted, verified users to access inventory\nCREATE POLICY \"Verified users can view inventory items\" ON inventory_items\n  FOR SELECT\n  TO authenticated\n  USING (\n    auth.jwt() ->> 'email_confirmed_at' IS NOT NULL\n    AND is_email_whitelisted(auth.jwt() ->> 'email')\n  );\n\nCREATE POLICY \"Verified users can insert inventory items\" ON inventory_items\n  FOR INSERT\n  TO authenticated\n  WITH CHECK (\n    auth.jwt() ->> 'email_confirmed_at' IS NOT NULL\n    AND is_email_whitelisted(auth.jwt() ->> 'email')\n    AND auth.uid() = user_id\n  );\n\nCREATE POLICY \"Verified users can update inventory items\" ON inventory_items\n  FOR UPDATE\n  TO authenticated\n  USING (\n    auth.jwt() ->> 'email_confirmed_at' IS NOT NULL\n    AND is_email_whitelisted(auth.jwt() ->> 'email')\n  )\n  WITH CHECK (\n    auth.jwt() ->> 'email_confirmed_at' IS NOT NULL\n    AND is_email_whitelisted(auth.jwt() ->> 'email')\n  );\n\nCREATE POLICY \"Verified users can delete inventory items\" ON inventory_items\n  FOR DELETE\n  TO authenticated\n  USING (\n    auth.jwt() ->> 'email_confirmed_at' IS NOT NULL\n    AND is_email_whitelisted(auth.jwt() ->> 'email')\n  );\n\n-- RLS Policies for profiles table\nDROP POLICY IF EXISTS \"Users can view own profile\" ON profiles;\nDROP POLICY IF EXISTS \"Users can update own profile\" ON profiles;\n\nCREATE POLICY \"Users can view own profile\" ON profiles\n  FOR SELECT\n  TO authenticated\n  USING (\n    auth.uid() = id\n    AND is_email_whitelisted(auth.jwt() ->> 'email')\n  );\n\nCREATE POLICY \"Users can update own profile\" ON profiles\n  FOR UPDATE\n  TO authenticated\n  USING (\n    auth.uid() = id\n    AND is_email_whitelisted(auth.jwt() ->> 'email')\n  )\n  WITH CHECK (\n    auth.uid() = id\n    AND is_email_whitelisted(auth.jwt() ->> 'email')\n  );\n\n-- RLS Policies for email_whitelist (admin only)\nCREATE POLICY \"Only admins can view whitelist\" ON email_whitelist\n  FOR SELECT\n  TO authenticated\n  USING (\n    auth.jwt() ->> 'email' = 'john.barr@mainecc.edu'\n  );\n\nCREATE POLICY \"Only admins can modify whitelist\" ON email_whitelist\n  FOR ALL\n  TO authenticated\n  USING (\n    auth.jwt() ->> 'email' = 'john.barr@mainecc.edu'\n  )\n  WITH CHECK (\n    auth.jwt() ->> 'email' = 'john.barr@mainecc.edu'\n  );\n\n-- RLS Policies for audit_log (admin only)\nCREATE POLICY \"Only admins can view audit log\" ON audit_log\n  FOR SELECT\n  TO authenticated\n  USING (\n    auth.jwt() ->> 'email' = 'john.barr@mainecc.edu'\n  );\n\nCREATE POLICY \"System can insert audit log\" ON audit_log\n  FOR INSERT\n  TO authenticated\n  WITH CHECK (TRUE);\n\n-- Create triggers for automatic audit logging\nCREATE OR REPLACE FUNCTION audit_trigger_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF TG_OP = 'INSERT' THEN\n    PERFORM log_audit_event(\n      'INSERT',\n      TG_TABLE_NAME,\n      NEW.id::TEXT,\n      NULL,\n      to_jsonb(NEW)\n    );\n    RETURN NEW;\n  ELSIF TG_OP = 'UPDATE' THEN\n    PERFORM log_audit_event(\n      'UPDATE',\n      TG_TABLE_NAME,\n      NEW.id::TEXT,\n      to_jsonb(OLD),\n      to_jsonb(NEW)\n    );\n    RETURN NEW;\n  ELSIF TG_OP = 'DELETE' THEN\n    PERFORM log_audit_event(\n      'DELETE',\n      TG_TABLE_NAME,\n      OLD.id::TEXT,\n      to_jsonb(OLD),\n      NULL\n    );\n    RETURN OLD;\n  END IF;\n  RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Add audit triggers to inventory_items\nDROP TRIGGER IF EXISTS audit_inventory_items ON inventory_items;\nCREATE TRIGGER audit_inventory_items\n  AFTER INSERT OR UPDATE OR DELETE ON inventory_items\n  FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();\n\n-- Create function to validate user registration\nCREATE OR REPLACE FUNCTION validate_user_registration()\nRETURNS TRIGGER AS $$\nBEGIN\n  -- Check if email is whitelisted\n  IF NOT is_email_whitelisted(NEW.email) THEN\n    RAISE EXCEPTION 'Email domain not authorized for registration: %', NEW.email;\n  END IF;\n  \n  -- Log registration attempt\n  PERFORM log_audit_event(\n    'USER_REGISTRATION_ATTEMPT',\n    'auth.users',\n    NEW.id::TEXT,\n    NULL,\n    jsonb_build_object('email', NEW.email, 'created_at', NEW.created_at)\n  );\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Add trigger for user registration validation\nDROP TRIGGER IF EXISTS validate_user_registration_trigger ON auth.users;\nCREATE TRIGGER validate_user_registration_trigger\n  BEFORE INSERT ON auth.users\n  FOR EACH ROW EXECUTE FUNCTION validate_user_registration();\n\n-- Create security monitoring views (admin only)\nCREATE OR REPLACE VIEW security_dashboard AS\nSELECT \n  'failed_logins' as metric,\n  COUNT(*) as count,\n  DATE_TRUNC('hour', created_at) as time_bucket\nFROM audit_log \nWHERE action = 'FAILED_LOGIN'\n  AND created_at > NOW() - INTERVAL '24 hours'\nGROUP BY DATE_TRUNC('hour', created_at)\nUNION ALL\nSELECT \n  'inventory_changes' as metric,\n  COUNT(*) as count,\n  DATE_TRUNC('hour', created_at) as time_bucket\nFROM audit_log \nWHERE table_name = 'inventory_items'\n  AND created_at > NOW() - INTERVAL '24 hours'\nGROUP BY DATE_TRUNC('hour', created_at)\nORDER BY time_bucket DESC;\n\n-- Grant necessary permissions\nGRANT USAGE ON SCHEMA public TO authenticated;\nGRANT SELECT, INSERT, UPDATE, DELETE ON inventory_items TO authenticated;\nGRANT SELECT, UPDATE ON profiles TO authenticated;\nGRANT SELECT ON email_whitelist TO authenticated;\nGRANT INSERT ON audit_log TO authenticated;\nGRANT EXECUTE ON FUNCTION is_email_whitelisted(TEXT) TO authenticated;\nGRANT EXECUTE ON FUNCTION log_audit_event(TEXT, TEXT, TEXT, JSONB, JSONB) TO authenticated;\n\n-- Create indexes for performance\nCREATE INDEX IF NOT EXISTS idx_email_whitelist_email ON email_whitelist(email);\nCREATE INDEX IF NOT EXISTS idx_email_whitelist_domain ON email_whitelist(domain);\nCREATE INDEX IF NOT EXISTS idx_audit_log_user_id ON audit_log(user_id);\nCREATE INDEX IF NOT EXISTS idx_audit_log_created_at ON audit_log(created_at);\nCREATE INDEX IF NOT EXISTS idx_audit_log_action ON audit_log(action);\n\n-- Add comments for documentation\nCOMMENT ON TABLE email_whitelist IS 'Stores whitelisted email addresses and domains for system access';\nCOMMENT ON TABLE audit_log IS 'Comprehensive audit log for security monitoring and compliance';\nCOMMENT ON FUNCTION is_email_whitelisted(TEXT) IS 'Checks if an email address is authorized for system access';\nCOMMENT ON FUNCTION log_audit_event(TEXT, TEXT, TEXT, JSONB, JSONB) IS 'Logs security and audit events for monitoring';"