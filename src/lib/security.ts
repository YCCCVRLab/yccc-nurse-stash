// Security utilities and configurations for YCCC Nursing Inventory\n\n// Rate limiting configuration\nexport const RATE_LIMITS = {\n  LOGIN_ATTEMPTS: {\n    MAX_ATTEMPTS: 5,\n    WINDOW_MS: 15 * 60 * 1000, // 15 minutes\n    LOCKOUT_DURATION: 30 * 60 * 1000, // 30 minutes\n  },\n  API_REQUESTS: {\n    MAX_REQUESTS: 100,\n    WINDOW_MS: 60 * 1000, // 1 minute\n  },\n};\n\n// Session configuration\nexport const SESSION_CONFIG = {\n  TIMEOUT_MS: 30 * 60 * 1000, // 30 minutes\n  REFRESH_THRESHOLD_MS: 5 * 60 * 1000, // 5 minutes before expiry\n  MAX_SESSION_DURATION: 8 * 60 * 60 * 1000, // 8 hours\n};\n\n// Input validation patterns\nexport const VALIDATION_PATTERNS = {\n  EMAIL: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/,\n  MAINECC_EMAIL: /^[a-zA-Z0-9._%+-]+@mainecc\\.edu$/i,\n  STRONG_PASSWORD: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]).{12,}$/,\n  SAFE_TEXT: /^[a-zA-Z0-9\\s\\-_.,!?()]+$/, // Prevents XSS in text inputs\n};\n\n// Security headers for API requests\nexport const SECURITY_HEADERS = {\n  'Content-Type': 'application/json',\n  'X-Content-Type-Options': 'nosniff',\n  'X-Frame-Options': 'DENY',\n  'X-XSS-Protection': '1; mode=block',\n  'Referrer-Policy': 'strict-origin-when-cross-origin',\n};\n\n// Input sanitization function\nexport const sanitizeInput = (input: string): string => {\n  if (!input) return '';\n  \n  return input\n    .trim()\n    .replace(/[<>\"'&]/g, (match) => {\n      const entities: { [key: string]: string } = {\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#x27;',\n        '&': '&amp;',\n      };\n      return entities[match] || match;\n    })\n    .substring(0, 1000); // Limit length to prevent buffer overflow\n};\n\n// Email validation with whitelist check\nexport const validateEmail = (email: string): { isValid: boolean; errors: string[] } => {\n  const errors: string[] = [];\n  \n  if (!email) {\n    errors.push('Email is required');\n    return { isValid: false, errors };\n  }\n  \n  if (!VALIDATION_PATTERNS.EMAIL.test(email)) {\n    errors.push('Invalid email format');\n  }\n  \n  if (!VALIDATION_PATTERNS.MAINECC_EMAIL.test(email)) {\n    errors.push('Only @mainecc.edu email addresses are allowed');\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n};\n\n// Password strength validation\nexport const validatePasswordStrength = (password: string): { \n  isValid: boolean; \n  errors: string[];\n  score: number; // 0-4 strength score\n} => {\n  const errors: string[] = [];\n  let score = 0;\n  \n  if (!password) {\n    errors.push('Password is required');\n    return { isValid: false, errors, score: 0 };\n  }\n  \n  // Length check\n  if (password.length < 12) {\n    errors.push('Password must be at least 12 characters long');\n  } else {\n    score += 1;\n  }\n  \n  // Character type checks\n  if (!/[a-z]/.test(password)) {\n    errors.push('Password must contain at least one lowercase letter');\n  } else {\n    score += 1;\n  }\n  \n  if (!/[A-Z]/.test(password)) {\n    errors.push('Password must contain at least one uppercase letter');\n  } else {\n    score += 1;\n  }\n  \n  if (!/[0-9]/.test(password)) {\n    errors.push('Password must contain at least one number');\n  } else {\n    score += 1;\n  }\n  \n  if (!/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/.test(password)) {\n    errors.push('Password must contain at least one special character');\n  } else {\n    score += 1;\n  }\n  \n  // Common password check\n  const commonPasswords = [\n    'password', 'admin', '123456', 'qwerty', 'letmein', 'welcome',\n    'monkey', 'dragon', 'master', 'administrator', 'root', 'toor',\n    'password123', 'admin123', 'password1', 'password12'\n  ];\n  \n  const lowerPassword = password.toLowerCase();\n  if (commonPasswords.some(common => lowerPassword.includes(common))) {\n    errors.push('Password contains common patterns - please choose a more unique password');\n    score = Math.max(0, score - 2);\n  }\n  \n  // Sequential characters check\n  if (/123|abc|qwe|asd|zxc/i.test(password)) {\n    errors.push('Avoid sequential characters in your password');\n    score = Math.max(0, score - 1);\n  }\n  \n  return {\n    isValid: errors.length === 0 && score >= 4,\n    errors,\n    score: Math.min(4, score),\n  };\n};\n\n// Rate limiting utility\nclass RateLimiter {\n  private attempts: Map<string, { count: number; firstAttempt: number; lockedUntil?: number }> = new Map();\n  \n  isRateLimited(identifier: string, maxAttempts: number, windowMs: number, lockoutMs?: number): boolean {\n    const now = Date.now();\n    const record = this.attempts.get(identifier);\n    \n    if (!record) {\n      this.attempts.set(identifier, { count: 1, firstAttempt: now });\n      return false;\n    }\n    \n    // Check if currently locked out\n    if (record.lockedUntil && now < record.lockedUntil) {\n      return true;\n    }\n    \n    // Reset if window has passed\n    if (now - record.firstAttempt > windowMs) {\n      this.attempts.set(identifier, { count: 1, firstAttempt: now });\n      return false;\n    }\n    \n    // Increment attempt count\n    record.count++;\n    \n    // Check if exceeded max attempts\n    if (record.count > maxAttempts) {\n      if (lockoutMs) {\n        record.lockedUntil = now + lockoutMs;\n      }\n      return true;\n    }\n    \n    return false;\n  }\n  \n  reset(identifier: string): void {\n    this.attempts.delete(identifier);\n  }\n  \n  getRemainingAttempts(identifier: string, maxAttempts: number): number {\n    const record = this.attempts.get(identifier);\n    if (!record) return maxAttempts;\n    return Math.max(0, maxAttempts - record.count);\n  }\n}\n\nexport const rateLimiter = new RateLimiter();\n\n// Session management utilities\nexport class SessionManager {\n  private lastActivity: number = Date.now();\n  private sessionStart: number = Date.now();\n  private warningShown: boolean = false;\n  \n  updateActivity(): void {\n    this.lastActivity = Date.now();\n    this.warningShown = false;\n  }\n  \n  isSessionExpired(): boolean {\n    const now = Date.now();\n    const inactiveTime = now - this.lastActivity;\n    const totalTime = now - this.sessionStart;\n    \n    return inactiveTime > SESSION_CONFIG.TIMEOUT_MS || \n           totalTime > SESSION_CONFIG.MAX_SESSION_DURATION;\n  }\n  \n  shouldShowWarning(): boolean {\n    if (this.warningShown) return false;\n    \n    const now = Date.now();\n    const timeUntilExpiry = SESSION_CONFIG.TIMEOUT_MS - (now - this.lastActivity);\n    \n    if (timeUntilExpiry <= SESSION_CONFIG.REFRESH_THRESHOLD_MS && timeUntilExpiry > 0) {\n      this.warningShown = true;\n      return true;\n    }\n    \n    return false;\n  }\n  \n  reset(): void {\n    this.lastActivity = Date.now();\n    this.sessionStart = Date.now();\n    this.warningShown = false;\n  }\n}\n\nexport const sessionManager = new SessionManager();\n\n// Security event logging\nexport const logSecurityEvent = (\n  event: string, \n  details: Record<string, any> = {},\n  level: 'info' | 'warning' | 'error' = 'info'\n): void => {\n  const logEntry = {\n    timestamp: new Date().toISOString(),\n    event,\n    level,\n    userAgent: navigator.userAgent,\n    url: window.location.href,\n    ...details,\n  };\n  \n  // In production, send to monitoring service\n  if (level === 'error' || level === 'warning') {\n    console.warn('🚨 Security Event:', logEntry);\n  } else {\n    console.log('🔐 Security Event:', logEntry);\n  }\n  \n  // Store in local storage for debugging (remove in production)\n  try {\n    const existingLogs = JSON.parse(localStorage.getItem('security_logs') || '[]');\n    existingLogs.push(logEntry);\n    // Keep only last 100 entries\n    if (existingLogs.length > 100) {\n      existingLogs.splice(0, existingLogs.length - 100);\n    }\n    localStorage.setItem('security_logs', JSON.stringify(existingLogs));\n  } catch (error) {\n    console.error('Failed to store security log:', error);\n  }\n};\n\n// Content Security Policy helper\nexport const getCSPDirectives = (): string => {\n  return [\n    \"default-src 'self'\",\n    \"script-src 'self' 'unsafe-inline' https://jwniuibwpdecgntmrhsb.supabase.co\",\n    \"style-src 'self' 'unsafe-inline'\",\n    \"img-src 'self' data: https:\",\n    \"font-src 'self' data:\",\n    \"connect-src 'self' https://jwniuibwpdecgntmrhsb.supabase.co wss://jwniuibwpdecgntmrhsb.supabase.co\",\n    \"frame-ancestors 'none'\",\n    \"base-uri 'self'\",\n    \"form-action 'self'\",\n  ].join('; ');\n};\n\n// Secure random string generation\nexport const generateSecureToken = (length: number = 32): string => {\n  const array = new Uint8Array(length);\n  crypto.getRandomValues(array);\n  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n};\n\n// XSS protection for displaying user content\nexport const escapeHtml = (unsafe: string): string => {\n  return unsafe\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;');\n};\n\n// Environment-specific security configurations\nexport const getSecurityConfig = () => {\n  const isDevelopment = import.meta.env.DEV;\n  \n  return {\n    enableLogging: isDevelopment,\n    strictMode: !isDevelopment,\n    enableCSP: !isDevelopment,\n    enableRateLimit: true,\n    sessionTimeout: isDevelopment ? SESSION_CONFIG.TIMEOUT_MS * 2 : SESSION_CONFIG.TIMEOUT_MS,\n  };\n};"